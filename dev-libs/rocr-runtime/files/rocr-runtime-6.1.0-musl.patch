Fix compilation and symbol search with musl.

Bug: https://github.com/ROCm/ROCR-Runtime/issues/181
--- a/core/inc/checked.h
+++ b/core/inc/checked.h
@@ -58,7 +58,7 @@ template <uint64_t code, bool multiProcess = false> class Check final {
   Check(const Check&) { object_ = uintptr_t(this) ^ uintptr_t(code); }
   Check(Check&&) { object_ = uintptr_t(this) ^ uintptr_t(code); }
 
-  ~Check() { object_ = NULL; }
+  ~Check() { object_ = uintptr_t(NULL); }
 
   const Check& operator=(Check&& rhs) { return *this; }
   const Check& operator=(const Check& rhs) { return *this; }
--- a/core/runtime/default_signal.cpp
+++ b/core/runtime/default_signal.cpp
@@ -57,7 +57,7 @@ int BusyWaitSignal::rtti_id_ = 0;
 BusyWaitSignal::BusyWaitSignal(SharedSignal* abi_block, bool enableIPC)
     : Signal(abi_block, enableIPC) {
   signal_.kind = AMD_SIGNAL_KIND_USER;
-  signal_.event_mailbox_ptr = NULL;
+  signal_.event_mailbox_ptr = uint64_t(NULL);
 }
 
 hsa_signal_value_t BusyWaitSignal::LoadRelaxed() {
--- a/core/runtime/hsa.cpp
+++ b/core/runtime/hsa.cpp
@@ -155,7 +155,7 @@ template <class T> struct ValidityError<const T*> {
 
 template <class T>
 static __forceinline bool IsValid(T* ptr) {
-  return (ptr == NULL) ? NULL : ptr->IsValid();
+  return (ptr == NULL) ? false : ptr->IsValid();
 }
 
 namespace AMD {
--- a/core/util/lnx/os_linux.cpp
+++ b/core/util/lnx/os_linux.cpp
@@ -65,6 +65,16 @@
 #include <cpuid.h>
 #endif
 
+/*
+ * d_un.d_ptr is relative on non glibc systems
+ * elf(5) documents it this way, glibc diverts from this documentation
+ */
+#ifdef __GLIBC__
+#define ABS_ADDR(base, ptr) (ptr)
+#else
+#define ABS_ADDR(base, ptr) ((base) + (ptr))
+#endif
+
 namespace rocr {
 namespace os {
 
@@ -296,7 +306,7 @@ static int callback(struct dl_phdr_info* info, size_t size, void* data) {
         for (int j = 0;; j++) {
           if (dyn_section[j].d_tag == DT_NULL) break;
 
-          if (dyn_section[j].d_tag == DT_STRTAB) strings = (char*)(dyn_section[j].d_un.d_ptr);
+          if (dyn_section[j].d_tag == DT_STRTAB) strings = (char*)ABS_ADDR(info->dlpi_addr, dyn_section[j].d_un.d_ptr);
 
           if (dyn_section[j].d_tag == DT_STRSZ) limit = dyn_section[j].d_un.d_val;
         }
@@ -642,11 +652,13 @@ SharedMutex CreateSharedMutex() {
     fprintf(stderr, "rw lock attribute init failed: %s\n", strerror(err));
     return nullptr;
   }
+#if defined(__GLIBC__)
   err = pthread_rwlockattr_setkind_np(&attrib, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);
   if (err != 0) {
     fprintf(stderr, "Set rw lock attribute failure: %s\n", strerror(err));
     return nullptr;
   }
+#endif
 
   pthread_rwlock_t* lock = new pthread_rwlock_t;
   err = pthread_rwlock_init(lock, &attrib);
--- a/core/util/utils.h
+++ b/core/util/utils.h
@@ -74,7 +74,7 @@ static __forceinline void* _aligned_malloc(size_t size, size_t alignment) {
   return aligned_alloc(alignment, size);
 #else
   void *mem = NULL;
-  if (NULL != posix_memalign(&mem, alignment, size))
+  if (0 != posix_memalign(&mem, alignment, size))
     return NULL;
   return mem;
 #endif
--- a/image/util.h
+++ b/image/util.h
@@ -99,7 +99,7 @@ static __forceinline void* _aligned_malloc(size_t size, size_t alignment) {
   return aligned_alloc(alignment, size);
 #else
   void* mem = NULL;
-  if (NULL != posix_memalign(&mem, alignment, size)) return NULL;
+  if (0 != posix_memalign(&mem, alignment, size)) return NULL;
   return mem;
 #endif
 }
